# coding:utf-8
from kivy.app import App
from kivy.uix.image import Image
from kivy.clock import Clock
from kivy.graphics.texture import Texture
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.camera import Camera
from kivy.lang import Builder
import datetime
import time

import cv2 as cv
import imutils
from imutils import contours
from imutils import perspective
from scipy.spatial import distance as dist
import numpy as np

Builder.load_string('''
<KivyCamera>:
    SmoothToggleButton:
        text: 'Estimate'
        on_press: root.switch_estimate()
        size_hint_y: None
        height: '48dp'
    SmoothButton:
        text: 'Save'
        size_hint_y: None
        height: '48dp'
        on_press: root.capture_image(root.get_frame())
    SmoothButton:
        text: 'Gallery'
        size_hint_y: None
        height: '48dp'
        on_press: root.capture_image(root.get_frame())

<SmoothButton@Button>:
    background_color: (0, 0, 0, 0)
    background_normal: ''
    border_radius: [18]
    back_color: (0, 0.5, 0.5, 1)
    canvas.before:
        Color:
            rgba: self.back_color
        RoundedRectangle:
            size: self.size
            pos: self.pos
            radius: self.border_radius

<SmoothToggleButton@ToggleButton>:
    background_color: (0, 0, 0, 0)
    background_normal: ''
    border_radius: [18]
    back_color: (0, 0.5, 0.5, 1)
    canvas.before:
        Color:
            rgba: self.back_color
        RoundedRectangle:
            size: self.size
            pos: self.pos
            radius: self.border_radius
''')

frame = cv.VideoCapture(0).read()
play = False

def midpoint(ptA, ptB):
    return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5) 

def estimate_size(frame1):
    global frame
    frame = frame1

    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    gray = cv.GaussianBlur(gray, (7, 7), 0)

    edged = cv.Canny(gray, 50, 100)
    edged = cv.dilate(edged, None, iterations=1)
    edged = cv.erode(edged, None, iterations=1)

    cnts = cv.findContours(edged.copy(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    (cnts, _) = contours.sort_contours(cnts)
    reference = None
    num_object = 3
    i = 0

    for c in cnts:
        if cv.contourArea(c) < 100:
            continue

        #orig = frame.copy()
        box = cv.minAreaRect(c)
        box = cv.cv.BoxPoints(box) if imutils.is_cv2() else cv.boxPoints(box)
        box = np.array(box, dtype="int")

        box = perspective.order_points(box)
        #cv.drawContours(orig, [box.astype("int")], -1, (0, 255, 0), 2)
        cv.drawContours(frame, [box.astype("int")], -1, (0, 255, 0), 2)
 
        for (x, y) in box:
            #cv.circle(orig, (int(x), int(y)), 5, (0, 0, 255), -1)
            cv.circle(frame, (int(x), int(y)), 5, (0, 0, 255), -1)
 
        (tl, tr, br, bl) = box
        (tltrX, tltrY) = midpoint(tl, tr)
        (blbrX, blbrY) = midpoint(bl, br)

        (tlblX, tlblY) = midpoint(tl, bl)
        (trbrX, trbrY) = midpoint(tr, br)

        cv.circle(frame, (int(tltrX), int(tltrY)), 5, (255, 0, 0), -1)
        cv.circle(frame, (int(blbrX), int(blbrY)), 5, (255, 0, 0), -1)
        cv.circle(frame, (int(tlblX), int(tlblY)), 5, (255, 0, 0), -1)
        cv.circle(frame, (int(trbrX), int(trbrY)), 5, (255, 0, 0), -1)

        cv.line(frame, (int(tltrX), int(tltrY)), (int(blbrX), int(blbrY)), (255, 0, 255), 2)
        cv.line(frame, (int(tlblX), int(tlblY)), (int(trbrX), int(trbrY)), (255, 0, 255), 2)

        dA = dist.euclidean((tltrX, tltrY), (blbrX, blbrY))
        dB = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))

        if reference is None:
            reference = dB / 2.4

        dimA = dA / reference
        dimB = dB / reference

        cv.putText(frame, "{:.1f}cm".format(dimA), (int(tltrX - 15), int(tltrY - 10)), cv.FONT_HERSHEY_SIMPLEX, 0.65, (255, 255, 255), 2)
        cv.putText(frame, "{:.1f}cm".format(dimB), (int(trbrX - 15), int(trbrY - 10)), cv.FONT_HERSHEY_SIMPLEX, 0.65, (255, 255, 255), 2)

        i += 1
        if i >= num_object:
            break


class KivyCamera(Image, BoxLayout):
    def __init__(self, capture, fps, **kwargs):
        super(KivyCamera, self).__init__(**kwargs)
        self.capture = capture
        Clock.schedule_interval(self.update, 1.0 / fps)
    
    def update(self, dt):
        global frame, play
        ret, frame = self.capture.read()
        if ret:
            if play:
                estimate_size(frame)

            # convert it to texture
            buf1 = cv.flip(frame, 0)
            buf = buf1.tostring()
            image_texture = Texture.create(
                size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')
            image_texture.blit_buffer(buf, colorfmt='bgr', bufferfmt='ubyte')
            # display image from the texture
            self.texture = image_texture
    
    def capture_image(self, frame):
        timestr = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        cv.imwrite(str(timestr) + ".jpg", frame)
        print("Captured")

    def get_frame(self):
        global frame
        return frame

    def switch_estimate(self):
        global play
        play = not play

    '''
    def ListSensors():
        Mobile.SetCurrent("Nexus 7")
        for i in range (0,  Mobile.Device().SensorsCount):
            sensor = Mobile.Device().Sensor[i]
            Log.AppendFolder("Sensor " + IntToStr(i) + ": " + sensor.Name)
            Log.Message(sensor.Type)
            Log.Message("Value0: " + VarToStr(sensor.Values.Value0))
            Log.Message("Value1: " + VarToStr(sensor.Values.Value1))
            Log.Message("Value2: " + VarToStr(sensor.Values.Value2))
            Log.PopLogFolder()
    '''


class CameraTestApp(App):
    def build(self):
        self.capture = cv.VideoCapture(0)
        self.my_camera = KivyCamera(capture=self.capture, fps=30)
        return self.my_camera
 
    def on_stop(self):
        #without this, app will not exit even if the window is closed
        self.capture.release()
 
 
if __name__ == '__main__':
    CameraTestApp().run()
